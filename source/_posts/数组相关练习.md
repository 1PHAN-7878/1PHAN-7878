---
title: 数组相关练习
date: 2024-03-29 09:36:36
tags:
  - 算法
  - java
---

# 数组调整

教练使用整数数组 actions 记录一系列核心肌群训练项目编号。为增强训练趣味性，需要将所有奇数编号训练项目调整至偶数编号训练项目之前。请将调整后的训练项目编号以 数组 形式返回。

> ![image-20240329093759177](../images/image-20240329093759177.png)

也就是说奇数均放到偶数后面

简单想法使用List，来一个奇数add一个，最后再搞偶数就彳亍。

```java
class Solution {
    public int[] trainingPlan(int[] actions) {
        List<Integer> li = new ArrayList<>();
        for(int i = 0; i < actions.length; i++){
            if(actions[i] % 2 == 1){
                li.add(actions[i]);
            }
        }
        for(int i = 0; i < actions.length; i++){
            if(actions[i] % 2 == 0){
                li.add(actions[i]);
            }
        }
        int[] ans = new int[actions.length];
        for(int i = 0; i < actions.length; i++){
            ans[i] = li.get(i);
        }
        return ans;
    }
}
```

双指针

```java
class Solution {
    public int[] trainingPlan(int[] actions) {
        int i = 0, j = actions.length - 1, tmp;
        while(i < j) {
            while(i < j && (actions[i] & 1) == 1) i++;
            while(i < j && (actions[j] & 1) == 0) j--;
            tmp = actions[i];
            actions[i] = actions[j];
            actions[j] = tmp;
        }
        return actions;
    }
}

```

# 文件组合

待传输文件被切分成多个部分，按照原排列顺序，每部分文件编号均为一个 正整数（至少含有两个文件）。传输要求为：连续文件编号总和为接收方指定数字 target 的所有文件。请返回所有符合该要求的文件传输组合列表。

注意，返回时需遵循以下规则：

每种组合按照文件编号 升序 排列；
不同组合按照第一个文件编号 升序 排列。

![image-20240329211725197](../images/image-20240329211725197.png)

我采用的是双指针，直接维护指针之间这里区域的数值和。

```java
import java.util.*;

class Solution {
    public int[][] fileCombination(int target) {
        Map<Integer, Integer> map = new TreeMap<>();
        int pre = 1, nex = 2;
        int sum = 3;
        while(nex != target){
            if(sum > target){
                sum -= pre;
                pre++;
            }else if(sum == target){
                map.put(pre, nex);
                sum -= pre;
                pre++;
            }else{
                nex++;
                sum += nex;
                
            }
        }

        int[][] ans = new int[map.size()][];
        int index = 0;
        for(Map.Entry<Integer, Integer> entry : map.entrySet()){
            int[] tem = new int[entry.getValue() - entry.getKey()+1];
            for(int i = 0; i < entry.getValue() - entry.getKey() + 1; i++){
                tem[i] = i + entry.getKey();
            }
            ans[index++] = tem;
        }
        
        return ans;




    }
}
```

另一种是直接通过左端点和总和，搞出来右端点看是不是整数。只能说算的很好。

```java
class Solution {
    public int[][] fileCombination(int target) {
        int i = 1;
        double j = 2.0;
        List<int[]> res = new ArrayList<>();
        while(i < j) {
            j = (-1 + Math.sqrt(1 + 4 * (2 * target + (long) i * i - i))) / 2;
            if(i < j && j == (int)j) {
                int[] ans = new int[(int)j - i + 1];
                for(int k = i; k <= (int)j; k++)
                    ans[k - i] = k;
                res.add(ans);
            }
            i++;
        }
        return res.toArray(new int[0][]);
    }
}
```

